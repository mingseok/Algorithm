## 문제 해결 절차

1. 문제를 적는다.
2. 생각을 열심히 한다.
3. 해결책을 적는다.
4. 코드로 짠다.

<br/>

## 문제를 적는다??

1. 문제를 정의 혹은 이해 한다.

2. 이해한 내용을 바탕으로 어떠한 상황인지 분석 한다.

<br/>

### 문제를 해결하기 위해 필요한 정보는 크게 2가지 이다.

목표 = 해결할 문제가 무엇인지

상황 = 제한된 조건이 무엇인지, 따라야 하는 규칙은 어떤 것인지

문제를 해결 하는데 에 있어서 필요한 정보를 빠짐없이 적을 때까지 문제를 읽는다.

<br/>

### 3줄 요약,

1. 문제에서 주어진 목표와 상황을 알아 낸다.

2. 알아낸 정보를 조합하며, 분석 한다.
3. 문제를 푸는데 충분한 정보를 얻을 때까지 반복한다.

<br/><br/>

## 생각을 열심히 한다??

"모든 뛰어난 생각들은 단순하고, 무식한 방법에서 출발한다.”

갑자기 한 번에 효율적인 방법을 생각해내는 것은 쉽지 않는다.

컴퓨터 공학의 기초 학문인 자료구조, 알고리즘은 생각을 깎아 나가는 데에 필요하다.

<br/>

### 2줄 요약,

- 무식한 방법부터 생각해서 효율적으로 개선 시켜 나가자.

- 필요한 도구는 자료구조와 알고리즘이다.

<br/><br/>

## 해결책을 적는다??

생각으로만 실행으로 옮겨 지지 않겠죠.

생각을 잘 정리해서 실행할 수 있도록 만드는 것이 중요하다.

<br/>

또한, 열심히 생각한 해결책이 제한 상황을 만족하면서 문제를 해결하는지 확인하는 과정이 필요하다.

<br/>

해결책을 효과적으로 정리하기 위해서는 생각의 단위를 정해서 모듈화를 적절히 하는 과정이 필요하다.

<br/>

예를 들어, 정말 큰 케이크를 한 입에 먹을 순 없다.

먹을 수 있는 크기 정도로 나눠야 먹을 수 있는 거죠.

![이미지](/문제해결방법론/문제해결.PNG)

<br/>

### 생각을 모듈화 한다는 것은 어떤 말일까??

목표를 이루기 위한 세부 하위 목표를 설정하는 것이죠.

<br/>

목표를 언제까지 나누는 것이 좋냐면,

내가 해결할 수 있는 단위면서 내가 행동으로 옮길 수 있는 단위까지 쪼개는 것이 좋다.

<br/>

처음에는 하위 목표가 많이 존재할 수 있다.

계속된 연습을 통해 내가 해결할 수 있는 하위 목표의 크기가 커진다면,

나눠야 할 하위 목표의 개수는 줄어들게 되겠죠.

<br/>

만약 연습을 통해 한 입에 먹을 수 있는 케이크의 크기가 커진다면,

케이크를 몇 조각 쪼개지 않아도 한 입에 먹을 수 있다.

<br/>

추천 드리는 하위 목표의 가장 작은 단위는 하나의 행위를 하는 함수를 제작할 수 있는 정도이다.

각각의 모듈화된 목표(=함수)를 통해 문제를 해결하는 것이죠.

<br/>

이때 얻을 수 있는 이점은 어떤 생각(=함수)에서 실수했는지 파악하기 쉽다.

또한, 각각의 생각(=함수)를 따로 테스트해 볼 수 있음으로 큰 실수를 할 확률이 낮아 진다.

<br/>

<aside>

💡 케이크 = 문제의 최종 목표

💡 케이크 한 조각 = 하위 목표

💡 한 입에 먹을 수 있는 크기 = 행동할 수 있는 단위

</aside>

<br/>

### 생각간의 관계를 살펴 보자.

하위 목표를 만들고, 각각의 하위 목표의 순서를 인식하고 있는 것이 중요 하다.

A라는 목표를 이뤄야 B 목표를 해결할 수 있는 종속 관계가 존재할 것이다.

만약 순서가 필요없을 경우, 문제 해결을 적절히 할 수 있는 순서로 목표를 해결 하자.

<br/>

### 3줄 요약,

- 생각의 단위를 내가 감당할 수 있을 만큼 쪼갠다.

- 쪼갠 생각들의 관계를 보고 절차를 매긴다.
- 분석한 문제와 생각해낸 해결책을 1:1 맵핑 해보자.

<br/><br/>

## 코드로 짠다??

구현 능력이 부족한 부분은 앞서 하위 목표를 쪼갤때 "내가 감당할 수 있을 만큼" 분해하기 때문에 문제되지 않아야 된다.

<br/><br/>

## 1 ~ 4 까지의 과정을 세밀하게 나누기.

문제를 적는다.

1-1. 문제의 목표를 파악한다.

1-2. 문제의 제한 상황을 알아 낸다.

1-3. 얻은 정보를 바탕으로 문제를 분석 한다.

<br/>

생각을 열심히 한다.

2-1. 가장 단순하고 무식한 방법부터 생각 한다.

2-2. 해당 생각을 자료구조와 알고리즘으로 개선 시켜 나간다.

<br/>

해결책을 적는다.

3-1. 하위 목표를 설정 한다.

3-2. 각 하위 목표끼리의 관계를 파악 한다.

3-3. 완성된 해결책과 분석한 문제를 비교 한다.

<br/>

코드로 짠다.

4-1. 각각의 하위 목표를 함수로 구현 한다.

4-2. 함수단위로 작게 작게 테스트를 진행 한다.

4-3. 실제 문제를 해결하는지 확인 한다.

<br/><br/>

## 적으면서 풀면 뭐가 좋을까??

문제에 대한 생각을 글로 적으면서 푼다는 것은 정말 귀찮은 일이다.

귀찮은 일임에도 불구하고 해야 되는 이유를 4가지 적어 본다..

<br/>

저는 생각의 흐름이 시냇물과 같다고 본다.

흐르는 시냇물에서 물을 움켜쥘 수 없듯이

생각하는 중에 특정 생각을 기억하고 있기란 쉽지 않다.

![이미지](/문제해결방법론/문제해결2.PNG)

<br/>

생각도 하나의 탐색 과정 이다.

탐색 과정을 기록한다면, 다시 되돌아 갈 수 있고, 다른 길로 갈 수 있다.

올바른 기록은 현재 상태를 파악할 수 있도록 돕는다.

내가 무엇을 알고, 무엇을 챙겨야 하는지 알게 해준다.

<br/>

### 목표: 두 수 중 큰 수를 찾고 싶다.

Q. 컴퓨터가 아닌 내가 목표를 달성하기 위해 어떤 행위를 하는가, 절차를 밟는가?

A. 기준이 되는 수를 두고, 비교할 수를 둬서 기준 수가 비교하는 수에 비해 어떤 상태인지 본다. 

컴퓨터에서는 조건문이 있다.

<br/>

### 목표: 수열에서 특정 숫자 k가 몇 번 나왔는지 알고 싶다.

Q. 컴퓨터가 아닌 내가 목표를 달성하기 위해 어떤 행위를 하는가, 절차를 밟는가?

A. 숫자가 나올 때마다 체크를 하고, 체크한 개수를 세어준다.

<br/>

Q. 체크를 컴퓨터로 할 수 있는가? 체크한 개수를 컴퓨터로 세어줄 수 있는가?

A. 있다면 코드로 변환, 없다면 조금 더 생각

체크할 수 있다 -> 조건문

체크한 개수를 컴퓨터로 세어준다는 것은 모르겠다.

<br/>

Q. 내가 숫자를 어떻게 세었었는가

A. 어릴때는 손가락으로 세어줬다. 커서는 아무 종이에 숫자를 증가 시켰다.

손과 종이에 해당하는 것이 변수구나.

변수에 숫자를 증감시킨다.

정리하자면 조건문으로 k인지 체크하고, 만약 k라면 변수에 숫자를 1씩 증가
시켜준다.(단, 변수는 0부터 시작)

<br/>

<aside>

💡 한 번에 해결하기 어려운 문제는 내가 해결할 수 있는 단위로 쪼개서 분할 정복합니다. 할 수 있는 방법에서 목표 달성 할 때까지 확장한다.

</aside>

<br/>

### 목표: 배열에서 가장 큰 수를 찾고 싶다.

Q. 내가 할 수 있는 것은 무엇일까?

A. 두 수를 비교해서 큰 값을 알 수 있다.

<br/>

Q. 그렇다면 세 수 중 큰 값을 얻을 수 있는가?

그렇다면 네 수는?

그렇다면 배열을?

<br/>

<aside>

💡 생각의 방향을 바꿔보자

</aside>

<br/><br/>

## 실생활 예시

### 문제: 부탁한 물건을 이모가 들고 와야 하는데 매번 까먹는다.

Q. 꼭 이모가 들고 와야 하는가?

A. 내가 이모한테 가서 물건을 가져온다.

<br/><br/>

## 숫자 야구([https://www.acmicpc.net/problem/2503](https://www.acmicpc.net/problem/2503))

목표: 정답이 될 수 있는 후보의 개수를 알고 싶다.

처음에 드는 생각: 입력으로 주어진 숫자들을 통해 후보를 만든다.(규칙 -> 후보)

<br/>

Q. 꼭 주어진 숫자들을 통해 후보를 만들어야 하는가?

후보에서 주어진 숫자들을 걸러낼 수 없나?

A. 모든 후보에서 입력으로 주어진 숫자들을 통해 걸러낸다. (후보 -> 규칙)

<br/><br/>

시간 복잡도, 공간 복잡도 공부하기 - [https://velog.io/@zoomg/time-space-complexity](https://velog.io/@zoomg/time-space-complexity)


참고 블로그 - https://velog.io/@zoomg/problemsolving0