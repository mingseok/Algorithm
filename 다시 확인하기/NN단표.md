## NN단표

```java
import java.util.Scanner;

public class eee {

    static long n;
    static long k;

    public static long getOrder(long x) {
        // x가 몇번째인지 반환하는 함수
        /**
         * 1 2 3 4 
         * 2 4 6 8
         * 3 6 9 12
         * 4 8 12 16  여기서  12는 몇번째 숫자냐? -> 13개
         *                    그렇다면 12는 14번째 숫자일 것이다.
         */

        long result = 0;

        for(int i = 1; i <= n; i++) {
            if(i * n < x) { // i*n 일 경우는 위에 표를 보자면 끝부분 4를 의미한다.
                result += n; // x보다 작다면 다 더하면 된다 왜? 
                             // x보다 작다는 뜻은 전부 x보다 작다는 뜻이기 때문이다.
                       
            } else {
                // 만약 3 6 9 12 에서 x = 10 이라면? 3을 나눠 주면 되는 것이다.
                // 즉, 10/3 하면 되는 것이다. 그러면 3개가 나올 것이다.
                // 추가 적으로 3단에서 니깐 /3 을 해주는 것이지
                // 4단이라면 /4를 해줘야 하는 것이다.

                if(x % i == 0) { // 만약 4 8 12 16 에서 
                                 // x = 12 / 4 를 한다면 -> 3 이 나온다
                                 // 그런데 작은 숫자의 갯수가 3개가 아닌 것이다 !!
                                 // 이유가 뭔가? 12 / 4 를 한다면 나누어 떨어지기 때문이다.
                                 // 그렇기 때문에 밑에 처럼 (x/i) - 1 해주는 것이다.
                    result += (x/i) - 1;

                } else {
                    result += x / i;
                }
            }
        }
        return result+1; // x가 몇번째인지 반환하게 되는 것이다.
                         // 왜 +1 하는가? 나보다 작은 숫자가 10개다 
                         // 그러면 나는 11번째니깐 +1 해준 것이다.
    }

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);

        n = sc.nextInt();
        k = sc.nextInt();

        // 타입 long 인거 확인 하기.
        long start = 1;
        long end = n * n + 1; // 왜 이런거냐면 end는 mid값에 포함이 될수가 없다.

        while(start+1 < end) { // 무슨말인가? start와 end가 딱 붙었다는 이야기이다.
            /*
             * 1 2 3 4
             * 2 4 6 8
             * 3 6 9 12
             * 4 8 12 16    k=8 이라면? 밑에 숫자 표를 보면 8번째 니깐 답이 4이다.
             * 
             * 1 2 2 3 3 4 4 4 6 6 8 8 9 12 12 16
             * 1 2 2 3 3 4 4 4 6 6 8 8 9 12 12 16
             * 
             * 
             * start: 항상 정답이 되는 숫자보다 작거나 작은 숫자.
             * start: 항상 k번째보다 작거나 같은 순서를 가지는 숫자 라고 한다면??
             * 8번째 숫자보다 항상 앞에 있는 즉, 1, 2, 3, 4까지를 말하는 것이다.
             * 다시 말해, 8번째 뒤로 있는 숫자들은 가리키지 않겠다고 하는 것이다.
             * 누가? start 가!! 항상 정답이 되는 숫자보다 작거나 같은 숫자만 가르키는 것이다.
             *
             * end: 항상 정답이 되는 숫자보다 큰 숫자를 가르킨다.
             * 
             * 
             * 만약 이런 상황이라면??
             *      start  end
             *       12    13
             * 딱 붙은 상황이다. 
             * start는 정답이 되는 숫자보다 작거나 같은 숫자만 가르킨다고 했다.
             * end는 항상 정답보다 큰 숫자만 가르킨다.
             * 그렇다면 정답이 누구일까????
             * 정답은 12 ~ 13 까지 그 사이까지 줄여 놓은건데 정답이 누구 일까??
             * end는 정답일 수가 없다 무조건 !! 
             * 이러면 start가 정답이란 것이다.
             * 즉, start 12 이고 end 13 같은 경우에는 정답이 start라고 
             * 확신 할 수 있는 것이다.
             * 
             */

            long mid = (start + end) / 2;

            long myOrder = getOrder(mid); // mid라는 숫자가 몇번째 숫자인지 알 수 있게 되는 것이다.

            if(myOrder <= k) { // 나는 8번째 숫자를 찾고 싶은데 방금 알아온 숫자가 2번째라고 한다.
                              // 그러면 방금 알아온 숫자보다 작은 애들은 더 볼 필요가 없다.
                              // 왜냐?? 내가 찾고 싶은 숫자보다 더 적을 테니깐
                start = mid; // 그리하여 start 를 mid로 옮겨야 되는 것이다.

            } else { // 8번째 보고 싶은데, 방금 알아온게 11번째라고 한다.
                     // 그렇다면 방금 본 11번째도 !! 볼 필요가 없는 것이다.
                end = mid;
            }
        }
        System.out.println(start);

    }
}
```